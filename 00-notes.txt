Lista de reproducción curso: 

https://youtube.com/playlist?list=PL3aEngjGbYhkg3AR-cytsvQIIGp1JgrY_

________________________________________________________________________
VIDEO #2, comparación Create React APP / Vite / Next
------------------------------------------------------------------------

Algunos conceptos. 

Cuando se "codifica en React" creando componentes, para que ese código pueda ser leido en un navegador, necesita una "traducción" a js. Estas herramientas que realizan esta traducción se denominan transpilador. Hay muchos y el mas famoso es BABEL. 

Adicionalmente, no solo React necesita ser "traducido" sino que el resto de los paquetes que facilitan CSS, HTML, etc, también. Entonces existen otros productos que hacen de intermediarios hacia el navegador en el formato de un servidor que devuelven a los nagegadores código que pueden interpretar. Estos paquetes se denominan Empaquetadores. WebPack es uno de los mas difundidos. 

Por último hay dependencias que hacen todo esto por si mismos y entonces los desarrolladores los incorporan y se "olvidan" de lo que hay por detrás. 

Algunos de estos paquetes son:
Create React APP
Vite
Next

>> Create React APP
npx create-react-app [nombre]
Ejemplo:
npx create-react-app prueba-crea

Opinión del video: no usar nunca Create React APP, usar Vite.

>> Vite
npm ini vite@latest
cd [carpeta del proyecto]
npm i

Opinión, para casi todas las aplicaciones, funciona muy bien. 

Vite es un framework de react, porque es un entorno de trabajo con todas las herramientas para que funciones como un proyecto real.

>> Next
npx create-next-app

Opinión, cuando usarlo: cuando queremos llegar a producción algo "serio" y con mucho conocimiento de React.

________________________________________________________________________
VIDEO #03 ¿Cómo funciona un DEV SERVER?
------------------------------------------------------------------------

Todo este ejemplo se realiza con vite.

Todos los proyectos de react, parten de un index.html; cuando alguien haga la petición de este archivo, vamos a devolverle este file. 

El run dev, intenta primero buscar un archivo estático. Si lo encuentra, lo carga, sino carga el index.html

Siempre busca un archivo estático, si no lo encuentra devuelve index.html.
Allí en index.html, con js se identificará la ruta y se mostrará tal contenido. 
La excepción, es si pones una extensión en una ruta .svg por ej, no nos va a devolver el index, sino que buscará un file en si y si no lo encuentra dará un error.

Empieza siempre buscando en public y luego en el resto. Si pedis un recurso si hay un archivo estático en public, lo devuelve, sino lo encuentra busca en todo el proyecto, sino lo encuentra devuelve el index.html
si tiene extensión busca un archivo. 


Diferencias entre desarrollo y producción. 
En desarrollo, si se hace f12 y se va a source, se verá que se agregan algunas líneas en el main.jsx por ejemplo para que se recargue con cada grabar. 

En producción es un poco distinto.
Para hacer un pase a producción, se ejecuta 

>> npm run build

, eso hace una minificación de todos los archivos, y deja todo en la carpeta assets, listo para enviar a producción. 

Para probar se puede ejecutar npm run preview y en otro puerto correrá esta versión minificada. 

________________________________________________________________________
VIDEO #04 ESLINT y PRETTIER en REACT
------------------------------------------------------------------------

lint: qué
formater: cómo

Cuando se comparte código, se acuerdan los formateadores y sus configuraciones, así todos comparten lo mismo, porque sino se leen "cambios fantasmas", que es cuando una persona abre y se formatea el código con un aspecto distinto, por con una indentación distinta a la de otro usuario. 

Ambos entonces ESLINT y PRETTIER, permitirán esta estandarización. 

>> npm i -D eslint

luego hay que configurar los parámetros. Esta configuración se puede hacer a mano, pero no es necesario ni recomendable. En su lugar se puede hacer:

>> npx eslint --init

A partir de esto se irán generando errores o warnings sobre la escritura.
Por ej, declarar una variable y no usarla, podría ser un error o un warn.
Cuando se hace foco en el error, se mostrará el valor que luego se puede configurar en .eslintrc.cjs. 
Por ej una variable que no se usa, no-unused-vars es el parámetro.
Para cambiar el comportamiento, en rules dentro de .eslintrc.cjs se agregará una línea:
'no-unused-vars': 'warn',
los valores pueden ser, off, on, o warn.

>> npm i -D prettier

Allí se realizarán algunas configuraciones cruzadas entre eslint y prettier.
Se puede agregar entonces un file .prettierrc para agregar algunas configuraciones allí. 
Se puede ir entonces a la configuración en la página de prettier, en DOCs - Options, y allí tiene los valores que se pueden agregar en formato json en el .prettierrc. En la documentación dice cómo sería la forma de override. 

Finalmente para resolver todos los conflictos, instalar:
>> npm i -D eslint-config-prettier

Agregar en el .eslintrc.cjs, y en extends agregar:
'eslint-config-prettier', cuando hay un conflicto, rige prettier.

También considerar que no se debe aplicar prettier ni ningún formato a los archivos que ya están en el build. Entonces así como hay un .gitignore, también hay que configurar un .prettierignore i gual  para el eslint: .slintignore
el node_modules ya está exceptuado en ambos casos por defecto.

Finalmente para que quede asociado tal cual a todo el proyecto y a todos lo que puedan llegar a accederlo, en el package-json, agregar: 
"format": "prettier --write ."
"lint": "eslint --fix . --ext .js,.jsx"

luego se puede hacer npm format y formateará todo, al igual que npm lint
En npm lint, puede aparecer un warning relacionado con la versión. 
Para elminiar ese warning, hay que agregar esto en el .eslintrc.cjs:
debajo de env
settings: {
  react: {
    version:'detect'
  }
},

________________________________________________________________________
VIDEO #05 JSX, Etiquetas
------------------------------------------------------------------------
Childrens es cualquier cosa que esté entre etiquetas. Al igual que en html, pueden ser otras etiquetas o texto simple. 
En jsx un children puede ser una expresión, que se pone entre {} y una vez evaluadas, devolverá un resultado. 

se pueden introducir textos, números. NO se pueden introducir objetos. undefined, null, true/false, no devuelven nada para pintar. Una función se puede ejecutar y pintará su resultado si es un elemento pintable. SI puede ser un array, cada elemento producirá su propio renderizado. Puede ser otra etiqueta.

Props, son lo que en html son atributos. 
No todos se llaman igual que en html
id por ej se llama igual
class se llama className en jsx
todas en camelCase
por ej tabindex, en jsx es tabindex

aria es una excepción, igual data- se mantienen con su guión.


________________________________________________________________________
VIDEO #06 Estructurar y establecer jerarquías para componentes REACT
------------------------------------------------------------------------Partiendo de un componente APP 

Para modularizar un componente, siempre es un componente por archivo y su nombre tiene relación con el nombre del componente.
Ej. componente VideoItem
Lo mas usual es que esté dentro de src->components

Dos formas de llamarlo. 
1) En primera mayúsculas, tal cual se llama el componente. VideoItem.jsx
2) video-item.jsx

El componente APP también se modulariza. Como es el nodo raíz, algunos suelen decidir ponerlo fuera de components directamente en src, digamos al mismo nivel que main.jsx.
Si bien puede tener props, se estila que no contenga propiedades, pero si fuera necesario podría tenerlas. 


________________________________________________________________________
VIDEO #07 Agregar CSS A REACT
------------------------------------------------------------------------la propieda style va en la etiqueta para style en línea, luego de la etiqueta como si fuera html. Pero es un objeto. Y las propiedades están en camelCase.

a) style

<div style={{
  width: '100',
  maxWidth: '600px'
}}>
...
</div

Claro que esto no es lo óptimo, siempre los navegadores funcionan de forma mas óptima interpretando css que styles en línea. 
Cuando se usan las etiquetas style, casi siempre con el dinamismo. 

b) crear una clase css, importar el index.css

En index.css se van angregando clases con sus estilos y dentro de los componentes, se agrega la propiedad 
<div className='nombreDeClase'>
...
</div>

El index.css se hace gigante según cuantos componentes tenga el proyecto. Entonces se puede tambié modularizar el css.
Se hace un archivo con el mismo nombre del componente .css y algunos eligen también ponerlo dentro de la misma carpeta de componentes. 

entonces ahora cada componente importa su propia hoja de estilos.
Igualmente aquí, es parecido a tener todo en un index.css, pero distribuido. Entonces también se puede hacer algo en lo que se empiecen a repetir nombres de clases y entonces se hace complicado de mantener y puede haber colisiones. 

c) Lograr que no se repitan los nombres de las clases, entonces que se generen automáticamente, CSS MODULES

Para generara un módulo de CSS, (esto quiza es por el entorno vite), se asigna 
.module.css y luego la extensión css
para importarlo se usa algo distinto:
import styles from './VideoItem.module.css';
y className={styles.container} va como una propidad del objeto styles y .container es el nombre de la etiqueta css.
allí aunque se llama container, iternamente el módulo le asigna un nombre aleaotorio. 

Si la clase tiene un nombre en el css: wrapper-list, en la propiedad styles dirá:
className={styles['wrapper-list']}
Por eso no se recomiendan los - en module css, mejor camelCase wrapperList

Cómo hago para agregar dos clases a un componente. 
con template strings agregando un espacio:
className={`${styles.wrapperList} ${styles.margin}`}

d) Finalmente reset de CSS
Esta hoja es la que iguala y hace homogéneos los estilos que aplican por defecto los distintos navegadores. 
Para ello se puede usar una librería como modern-normalize. 
Como cualquier paquete se podría instalar con npm install modern-normalize
Pero en el video se sugiere copiar directamente la hoja de estilos desde la página de modern:
https://github.com/sindresorhus/modern-normalize
Download Normal

El video sugiere llevar los css raíz a una carpeta dentro del src, y para este reset llamarlo por ejemplo normalize.css
También sugiere llevar allí el index.css y dentro del index, importar el normalize. Entonces en el main.jsx solo tengo el import del index.css


e) sass, es otra forma de escribir css. En el video se repasa muy rápido, consiste en nombrar distinto los archivos css x scss e instalar npm i -D sass. No lo vi muy en detalle.


________________________________________________________________________
VIDEO #08 Renderizado y virtual DOM
------------------------------------------------------------------------

El VDOM no almacena todo el DOM que son nodos muy complejos, sino que arranca desde el DIV el contenedor root. 

Cuando se carga el navegador, solo carga el html que tiene digamos, la etiqueta root o container.
REACT traslada el VDOM al DOM y se visualiza en la pantalla. RENDERIZADO, inicia en un nodo. El RENDERIZADO se inicia en el método root.render(), que recibe un nodo del VDMO, que sería el componente APP.

Cada nodo puede llamar y renderizar otro y así de manera recursiva. 

Por ejemplo, si al root.render() lo pones en un settimeout, a los 5 seg, en las herramientas de desarrollo del navegador, se verá el div "root" del index html vacío, y a los 5 segundos se completará con lo renderizado por REACT a partir de App. Crea el VDMO y lo traslada al DOM.

El orden en que se renderiza es siempre siguiendo la línea de cada componente. En este ejemplo, será primero APP, luego un video list y luego un video item; luego seguirá el próximo vide list con video item y así. Es decir cada componente que llama a otro, se ejecuta hasta el final de la cadena. 

Renderizar es generar un objeto, dado que todo lo que renderiza REACT es un objeto. Puede ser una etiqueta nativa o un componente. 
Cuando es una etiqueta nativa como un div, el type del objeto es "div". 

Cuando es un componente, el type del objeto es ()=>{}, es decir una función. Que al renderizarse ejecutará con las props que están también como propiedades de ese objeto Symbol(react.element)

Al final todo tiene que ser un componente nativo al que se transforma el componente.

Esto funciona así, porque luego del renderizado inicial, se pueden renderizar nodos en particular. 





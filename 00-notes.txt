Lista de reproducción curso: 

https://youtube.com/playlist?list=PL3aEngjGbYhkg3AR-cytsvQIIGp1JgrY_

________________________________________________________________________
VIDEO #2, comparación Create React APP / Vite / Next
------------------------------------------------------------------------

Algunos conceptos. 

Cuando se "codifica en React" creando componentes, para que ese código pueda ser leido en un navegador, necesita una "traducción" a js. Estas herramientas que realizan esta traducción se denominan transpilador. Hay muchos y el mas famoso es BABEL. 

Adicionalmente, no solo React necesita ser "traducido" sino que el resto de los paquetes que facilitan CSS, HTML, etc, también. Entonces existen otros productos que hacen de intermediarios hacia el navegador en el formato de un servidor que devuelven a los nagegadores código que pueden interpretar. Estos paquetes se denominan Empaquetadores. WebPack es uno de los mas difundidos. 

Por último hay dependencias que hacen todo esto por si mismos y entonces los desarrolladores los incorporan y se "olvidan" de lo que hay por detrás. 

Algunos de estos paquetes son:
Create React APP
Vite
Next

>> Create React APP
npx create-react-app [nombre]
Ejemplo:
npx create-react-app prueba-crea

Opinión del video: no usar nunca Create React APP, usar Vite.

>> Vite
npm ini vite@latest
cd [carpeta del proyecto]
npm i

Opinión, para casi todas las aplicaciones, funciona muy bien. 

Vite es un framework de react, porque es un entorno de trabajo con todas las herramientas para que funciones como un proyecto real.

>> Next
npx create-next-app

Opinión, cuando usarlo: cuando queremos llegar a producción algo "serio" y con mucho conocimiento de React.

________________________________________________________________________
VIDEO #03 ¿Cómo funciona un DEV SERVER?
------------------------------------------------------------------------

Todo este ejemplo se realiza con vite.

Todos los proyectos de react, parten de un index.html; cuando alguien haga la petición de este archivo, vamos a devolverle este file. 

El run dev, intenta primero buscar un archivo estático. Si lo encuentra, lo carga, sino carga el index.html

Siempre busca un archivo estático, si no lo encuentra devuelve index.html.
Allí en index.html, con js se identificará la ruta y se mostrará tal contenido. 
La excepción, es si pones una extensión en una ruta .svg por ej, no nos va a devolver el index, sino que buscará un file en si y si no lo encuentra dará un error.

Empieza siempre buscando en public y luego en el resto. Si pedis un recurso si hay un archivo estático en public, lo devuelve, sino lo encuentra busca en todo el proyecto, sino lo encuentra devuelve el index.html
si tiene extensión busca un archivo. 


Diferencias entre desarrollo y producción. 
En desarrollo, si se hace f12 y se va a source, se verá que se agregan algunas líneas en el main.jsx por ejemplo para que se recargue con cada grabar. 

En producción es un poco distinto.
Para hacer un pase a producción, se ejecuta 

>> npm run build

, eso hace una minificación de todos los archivos, y deja todo en la carpeta assets, listo para enviar a producción. 

Para probar se puede ejecutar npm run preview y en otro puerto correrá esta versión minificada. 

________________________________________________________________________
VIDEO #04 ESLINT y PRETTIER en REACT
------------------------------------------------------------------------

lint: qué
formater: cómo

Cuando se comparte código, se acuerdan los formateadores y sus configuraciones, así todos comparten lo mismo, porque sino se leen "cambios fantasmas", que es cuando una persona abre y se formatea el código con un aspecto distinto, por con una indentación distinta a la de otro usuario. 

Ambos entonces ESLINT y PRETTIER, permitirán esta estandarización. 

>> npm i -D eslint

luego hay que configurar los parámetros. Esta configuración se puede hacer a mano, pero no es necesario ni recomendable. En su lugar se puede hacer:

>> npx eslint --init

A partir de esto se irán generando errores o warnings sobre la escritura.
Por ej, declarar una variable y no usarla, podría ser un error o un warn.
Cuando se hace foco en el error, se mostrará el valor que luego se puede configurar en .eslintrc.cjs. 
Por ej una variable que no se usa, no-unused-vars es el parámetro.
Para cambiar el comportamiento, en rules dentro de .eslintrc.cjs se agregará una línea:
'no-unused-vars': 'warn',
los valores pueden ser, off, on, o warn.

>> npm i -D prettier

Allí se realizarán algunas configuraciones cruzadas entre eslint y prettier.
Se puede agregar entonces un file .prettierrc para agregar algunas configuraciones allí. 
Se puede ir entonces a la configuración en la página de prettier, en DOCs - Options, y allí tiene los valores que se pueden agregar en formato json en el .prettierrc. En la documentación dice cómo sería la forma de override. 

Finalmente para resolver todos los conflictos, instalar:
>> npm i -D eslint-config-prettier

Agregar en el .eslintrc.cjs, y en extends agregar:
'eslint-config-prettier', cuando hay un conflicto, rige prettier.

También considerar que no se debe aplicar prettier ni ningún formato a los archivos que ya están en el build. Entonces así como hay un .gitignore, también hay que configurar un .prettierignore i gual  para el eslint: .slintignore
el node_modules ya está exceptuado en ambos casos por defecto.

Finalmente para que quede asociado tal cual a todo el proyecto y a todos lo que puedan llegar a accederlo, en el package-json, agregar: 
"format": "prettier --write ."
"lint": "eslint --fix . --ext .js,.jsx"

luego se puede hacer npm format y formateará todo, al igual que npm lint
En npm lint, puede aparecer un warning relacionado con la versión. 
Para elminiar ese warning, hay que agregar esto en el .eslintrc.cjs:
debajo de env
settings: {
  react: {
    version:'detect'
  }
},

________________________________________________________________________
VIDEO #05 JSX, Etiquetas
------------------------------------------------------------------------
Childrens es cualquier cosa que esté entre etiquetas. Al igual que en html, pueden ser otras etiquetas o texto simple. 
En jsx un children puede ser una expresión, que se pone entre {} y una vez evaluadas, devolverá un resultado. 

se pueden introducir textos, números. NO se pueden introducir objetos. undefined, null, true/false, no devuelven nada para pintar. Una función se puede ejecutar y pintará su resultado si es un elemento pintable. SI puede ser un array, cada elemento producirá su propio renderizado. Puede ser otra etiqueta.

Props, son lo que en html son atributos. 
No todos se llaman igual que en html
id por ej se llama igual
class se llama className en jsx
todas en camelCase
por ej tabindex, en jsx es tabindex

aria es una excepción, igual data- se mantienen con su guión.


________________________________________________________________________
VIDEO #06 Estructurar y establecer jerarquías para componentes REACT
------------------------------------------------------------------------Partiendo de un componente APP 

Para modularizar un componente, siempre es un componente por archivo y su nombre tiene relación con el nombre del componente.
Ej. componente VideoItem
Lo mas usual es que esté dentro de src->components

Dos formas de llamarlo. 
1) En primera mayúsculas, tal cual se llama el componente. VideoItem.jsx
2) video-item.jsx

El componente APP también se modulariza. Como es el nodo raíz, algunos suelen decidir ponerlo fuera de components directamente en src, digamos al mismo nivel que main.jsx.
Si bien puede tener props, se estila que no contenga propiedades, pero si fuera necesario podría tenerlas. 


________________________________________________________________________
VIDEO #07 Agregar CSS A REACT
------------------------------------------------------------------------la propieda style va en la etiqueta para style en línea, luego de la etiqueta como si fuera html. Pero es un objeto. Y las propiedades están en camelCase.

a) style

<div style={{
  width: '100',
  maxWidth: '600px'
}}>
...
</div

Claro que esto no es lo óptimo, siempre los navegadores funcionan de forma mas óptima interpretando css que styles en línea. 
Cuando se usan las etiquetas style, casi siempre con el dinamismo. 

b) crear una clase css, importar el index.css

En index.css se van angregando clases con sus estilos y dentro de los componentes, se agrega la propiedad 
<div className='nombreDeClase'>
...
</div>

El index.css se hace gigante según cuantos componentes tenga el proyecto. Entonces se puede tambié modularizar el css.
Se hace un archivo con el mismo nombre del componente .css y algunos eligen también ponerlo dentro de la misma carpeta de componentes. 

entonces ahora cada componente importa su propia hoja de estilos.
Igualmente aquí, es parecido a tener todo en un index.css, pero distribuido. Entonces también se puede hacer algo en lo que se empiecen a repetir nombres de clases y entonces se hace complicado de mantener y puede haber colisiones. 

c) Lograr que no se repitan los nombres de las clases, entonces que se generen automáticamente, CSS MODULES

Para generara un módulo de CSS, (esto quiza es por el entorno vite), se asigna 
.module.css y luego la extensión css
para importarlo se usa algo distinto:
import styles from './VideoItem.module.css';
y className={styles.container} va como una propidad del objeto styles y .container es el nombre de la etiqueta css.
allí aunque se llama container, iternamente el módulo le asigna un nombre aleaotorio. 

Si la clase tiene un nombre en el css: wrapper-list, en la propiedad styles dirá:
className={styles['wrapper-list']}
Por eso no se recomiendan los - en module css, mejor camelCase wrapperList

Cómo hago para agregar dos clases a un componente. 
con template strings agregando un espacio:
className={`${styles.wrapperList} ${styles.margin}`}

d) Finalmente reset de CSS
Esta hoja es la que iguala y hace homogéneos los estilos que aplican por defecto los distintos navegadores. 
Para ello se puede usar una librería como modern-normalize. 
Como cualquier paquete se podría instalar con npm install modern-normalize
Pero en el video se sugiere copiar directamente la hoja de estilos desde la página de modern:
https://github.com/sindresorhus/modern-normalize
Download Normal

El video sugiere llevar los css raíz a una carpeta dentro del src, y para este reset llamarlo por ejemplo normalize.css
También sugiere llevar allí el index.css y dentro del index, importar el normalize. Entonces en el main.jsx solo tengo el import del index.css


e) sass, es otra forma de escribir css. En el video se repasa muy rápido, consiste en nombrar distinto los archivos css x scss e instalar npm i -D sass. No lo vi muy en detalle.


________________________________________________________________________
VIDEO #08 Renderizado y virtual DOM
------------------------------------------------------------------------

El VDOM no almacena todo el DOM que son nodos muy complejos, sino que arranca desde el DIV el contenedor root. 

Cuando se carga el navegador, solo carga el html que tiene digamos, la etiqueta root o container.
REACT traslada el VDOM al DOM y se visualiza en la pantalla. RENDERIZADO, inicia en un nodo. El RENDERIZADO se inicia en el método root.render(), que recibe un nodo del VDMO, que sería el componente APP.

Cada nodo puede llamar y renderizar otro y así de manera recursiva. 

Por ejemplo, si al root.render() lo pones en un settimeout, a los 5 seg, en las herramientas de desarrollo del navegador, se verá el div "root" del index html vacío, y a los 5 segundos se completará con lo renderizado por REACT a partir de App. Crea el VDMO y lo traslada al DOM.

El orden en que se renderiza es siempre siguiendo la línea de cada componente. En este ejemplo, será primero APP, luego un video list y luego un video item; luego seguirá el próximo vide list con video item y así. Es decir cada componente que llama a otro, se ejecuta hasta el final de la cadena. 

Renderizar es generar un objeto, dado que todo lo que renderiza REACT es un objeto. Puede ser una etiqueta nativa o un componente. 
Cuando es una etiqueta nativa como un div, el type del objeto es "div". 

Cuando es un componente, el type del objeto es ()=>{}, es decir una función. Que al renderizarse ejecutará con las props que están también como propiedades de ese objeto Symbol(react.element)

Al final todo tiene que ser un componente nativo al que se transforma el componente.

Esto funciona así, porque luego del renderizado inicial, se pueden renderizar nodos en particular. 


________________________________________________________________________
VIDEO #09 Estados
------------------------------------------------------------------------
Manejo de dinamismo. 
Necesitamos que nuestros componentes tengan un estado. 

Un componente tendrá una serie de características jsx y props estáticas y luego un estado.

renderizar es ejecutar la función de un componente y permitir que react lo renderice en el navegador. 

Se puede hacer renderizados selectivos. 

hook usestate

Hooks son funciones de la api de react y sirven para gestionar algunas de las características de react en nuestros componentes. 

Algunos de ellos:
Basics (son los core)
usestate
useEffect
useContext

Additional...
son otros que agregan características. 

En el AppUseState, se describe un ejemplo, el cual será un simple contador. 
El ejemplo es el renderizado de un componente Likes que es un botón al  cual se le pasa como parámetro un contador likes. En la función OnClik, se incrementa el contador en 1, pero el incrementar una variable en Javascritp no produce un resultado en el renderizado del componete. Se hace click, dentro de la función se incrementa el contador, pero el renderizado del componente quedó con el primer valor del parámetro. 

Necestiamos que se haga un nuevo renderizado, entonces para eso necesito creado un estado con el hook useState, este arranca con un valor que puede ser fijo o venir desde un params. 
El state es un array, siempre con dos elementos. [0]: es el estado actual y [1] es una función. 
Entonces un comando:
const state = useState(0);
devuelve un array state con dos componentes [0, f]. Puedo destructurarlo:
conts [state, setState] = useState(0);
Por convención entonces puedo llamar a estas variables destructuradas de una manera mas conveniente. Por ejemplo, state en este ejemplo, se representa por likes y por la misma convención llamamos a la función setLikes, es decir set + la variable que monitorea el estado. 
Esta función es la que alterará el valor de la variable de estado y entonces llamará un nuevo renderizado sobre el nodo, sobre el componente particular. 

Cuando la comparación no es un valor primitivo, sino un objeto o un array, lo que se compara es una referencia. 
const a = {}
const b = a; igualo las referencias. 
b.x = 7
a.x === b.x; devuelve true porque se apunta a la misma referencia, no son dos objetos distintos. 

si queremos hacer dos objetos para luego compararlos tengo que hacer
const a = {}
const b = {...a}     crea otro objeto b

Entonces cuando queremos validar cambios en objetos con useState, sino hago una copia, el useState({valor: value}), se lo va a asignar a la variable, pero a la misma referencia (como en const b = a), entonces para la función, este valor no cambiará. 

Importante. Si al useState() en lugar de enviarle un valor fijo o un parámetro, le paso una función, la particularidad es que esa función, que debe devolver el valor inicial del estado, ya NO se ejecutará mas. En el ejemplo sería el caso de getInitialState().
Esta función NO puede ser asíncrona porque esta devuelve una promesa que no se entiende por el renderizado de react. 


________________________________________________________________________
VIDEO #10 Formularios en REACT inputs controlados
------------------------------------------------------------------------
1. Gestionar formularios no controlados. 
En este enfoque, los cambios se tienen que realizar detectando un cambio con useState y en algún evento como un onSubmit por ejemplo. Dentro del onSubmit se ejectua la función de cambio de estado y el resultado se renderiza. 

También se puede poner la función de cambio del useState en el evento onChange del input. 

2. Gestionar formularios controlados. 
Cuando se habla de controlado, implica que el estado de un input lo controla directamente REACT a través de un estado y la propiedad value de los inputs

el value en un input, es distinto al que tiene en html que se entiende como el valor por defecto (el que se muestra grisado). Aquí para REACT el value es el valor actual. 

entonces yo puedo enviarle a value el valor de la variable de useState
value={search}
el valor de search lo voy a cambiar desde la función del useState en el onChange, o desde cualquier otro lugar.

Depende de la necesidad podremos usar uno u otro modelo, pero NO un mix, aunque lo soporta correctamente. 

________________________________________________________________________
VIDEO #11 SIDE EFFECT y USE EFFECT 
------------------------------------------------------------------------
En el dinamismo, no todo es renderizar cada vez que hay un cambio. Se podría por ejemplo, agregar un string de búsqueda a la url, cambiar el ícono de la aplicación, registrar métricas, etc. Desde el punto de vista del usuario, estos son acciones secundarias y desde el punto de vista del desarrollador, estas acciones secundarias se llaman side effects. 

Para eso REACT proporcina el hook de sideEffects

- Son consecuencia de un cambio de estado,
- se ejectuan después del renderizado
- el orden en el que se lanzan no es importante
- tienen implicaciones externas, es decir a diferencia del status que tiene efecto sobre el propio componente, esta acción puede tener implicaciones fuera. 

cuando es un side effect y cuando no
- definir la tarea
- detectar las acciones
- elegir cuál es la acción principal.

En el ejemplo jsx se tiene un contador. 
El contador tiene dos tareas, actualizar la interfaz del usuario con el h1 y el título de la ventana. Podemos decir que la acción principal es actualizar el h1 y actualizar el document.title sería un side effect. 

Si voy a agregando botones +2 +3 por ejemplo en los que en cada uno haga una actualización del document.title, tengo posibilidades de omitirlo. Adicionalmente, la renderización se producirá luego que se hagan estas acciones side. Es decir podemos estar desenfocando la prioridad de renderizar la acción principal condicionándolo a la ejecución de las sideEffects. 

Para eso se usa el useEffect. 
se llama siempre dentro de un componente useEffect(()=>{}) y ejecutará una función luego de todos los renderizados e IMPORTANTE, con los VALORES ACTUALIZADOS. 
El useEffect se ejecuta luego que se renderiza todo y esa función se ejecuta de modo asíncrona. 
y algo importante también es que se ejecuta ANTES del siguiente render del componente. 


________________________________________________________________________
VIDEO #12 USE EFFECT y ARRAY DE DEPENDENCIAS 
------------------------------------------------------------------------
Con las dependencias se podrá manejar en qué condiciones se ejecutará un useEffect. 

En el ejemplo se agrega un botón para incrementar el step, es decir cuántos pasos aumentará el contador. Se deja dentro del useEffect un console.log, y se ve que aunque se cambie el step, lo mismo se ejecuta la función del useEffect, y eso no es necesario porque el valor de count no cambia, sino solo cuando se aprieta el botón incrementar count.

Para esto en la función de useEffect, como 2do argumento, le podemos pasar un array de dependencias y allí le pasaremos qué cambios en qué valores se tomarán en cuenta para que se ejecute el useEffect. 

Si el array queda vacío, le estamos indicando que se ejecute una sola vez. Sería similar a poner un valor fijo en el array ['marca'], pero se recomienda que sea vacío. 

NO hay forma de evitar que se ejecute la primera vez. Si no queremos el efecto en la primera vez, tenemos que poner una lógica, como un if para identificar que se trata de la primera vez y sobre esa lógica decidir qué si y qué no. 

En general en el array van estados o props.


________________________________________________________________________
VIDEO #13 LIMPIAR USE EFFECT, RETURN y su CLEANUP 
------------------------------------------------------------------------
la función de useEffect, puede retornar una nueva función y en este caso, esta función se ejecutará justo antes de la función useEffect.

Esta función de cleanup también se ejecutará cuando se desmonte el componente. 

Si en el useEffect, se hizo un eventListener, en la función cleanup tiene que tener su correspondiente removeEventListener. 